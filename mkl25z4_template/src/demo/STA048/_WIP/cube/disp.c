/*
 * Name: disp.c
 * Author: Martin Stankus
 *
 */

#include "MKL25Z4.h"

#include "disp.h"
#include "disp_data.h"

#include "soc_def.h"
#include "res_alloc.h"
#include "crsec.h"
#include "bme.h"

#define DISP_I2C_FDIV_400K			0x11u //375000 Hz
#define DISP_I2C_FDIV_100K			0x22u //93750 Hz

#define DISP_CMD_PREF_SINGLE		0x80u
#define DISP_CMD_PREF_MULTI			0x00u

#define DISP_DATA_PREF_SINGLE		0xC0u
#define DISP_DATA_PREF_MULTI		0x40u

#define DISP_CMD_SMAM_LEN			3u
#define DISP_CMD_SMAM_PREF			DISP_CMD_PREF_MULTI
#define DISP_CMD_SMAM_OPCODE		0x20u
#define DISP_CMD_SMAM_ARG_HOR		0x00u
#define DISP_CMD_SMAM_ARG_VER		0x01u
#define DISP_CMD_SMAM_ARG_PAGE		0x02u

#define DISP_CMD_SCA_LEN			4u
#define DISP_CMD_SCA_PREF			DISP_CMD_PREF_MULTI
#define DISP_CMD_SCA_OPCODE			0x21u

#define DISP_CMD_SPA_LEN			4u
#define DISP_CMD_SPA_PREF			DISP_CMD_PREF_MULTI
#define DISP_CMD_SPA_OPCODE			0x22u

#define DISP_CMD_SDOFF_LEN			2u
#define DISP_CMD_SDOFF_PREF			DISP_CMD_PREF_SINGLE
#define DISP_CMD_SDOFF_OPCODE		0xAEu

#define DISP_CMD_SDON_LEN			2u
#define DISP_CMD_SDON_PREF			DISP_CMD_PREF_SINGLE
#define DISP_CMD_SDON_OPCODE		0xAFu

typedef enum {
	DISP_FSM_IDLE = 0,
	DISP_FSM_INIT_SDOFF,
	DISP_FSM_INIT_SMAM,
	DISP_FSM_INIT_SCA,
	DISP_FSM_INIT_SPA,
	DISP_FSM_INIT_WIPE,
	DISP_FSM_INIT_SDON,
	DISP_FSM_IMG
} DISP_FSM;

static const uint8_t disp_font[DISP_DATA_FONT_LEN] = {DISP_DATA_FONT};
static const uint8_t disp_img_test[DISP_DATA_IMG_LEN] = {DISP_DATA_IMG_TEST};

static uint16_t

void __attribute__ ((interrupt)) I2C0_IRQHandler(void)
{
	assert(!BME_UBFX_B(&I2C1->S, I2C_S_IAAS_SHIFT, 1u));
	assert(!BME_UBFX_B(&I2C1->S, I2C_S_ARBL_SHIFT, 1u));


	if (BME_UBFX_B(&I2C1->FLT, I2C_FLT_STOPF_SHIFT, 1u)) {

		assert(i2c_fsm == I2C_FSM_STOP);
		i2c_fsm = I2C_FSM_IDLE;
		I2C1->FLT = I2C_FLT_STOPF_MASK | I2C_FLT_STOPIE_MASK;
		I2C1->S = I2C_S_IICIF_MASK;

	} else {

		I2C1->S = I2C_S_IICIF_MASK;

		switch (i2c_fsm) {
		case I2C_FSM_WR_END:
			i2c_fsm = I2C_FSM_RD_ADDR;

			I2C1->C1 = I2C_C1_IICEN_MASK | I2C_C1_IICIE_MASK | I2C_C1_MST_MASK | I2C_C1_TX_MASK | I2C_C1_RSTA_MASK;
			I2C1->D = IIC_MAKE_CTRL_RD(IIC_ADDR_FRAM_DEV0);

			break;
		case I2C_FSM_RD_ADDR:
			i2c_fsm = I2C_FSM_RD;

			DMA0->DMA[0u].SAR = (uint32_t) &I2C1->D;
			DMA0->DMA[0u].DAR = (uint32_t) &data;
			DMA0->DMA[0u].DSR_BCR = DMA_DSR_BCR_BCR(XFER_DATA_LEN - 1u);
			DMA0->DMA[0u].DCR = DMA_DCR_EINT_MASK | DMA_DCR_ERQ_MASK | DMA_DCR_CS_MASK |
								DMA_DCR_SSIZE(1u) | DMA_DCR_DSIZE(1u) | DMA_DCR_DINC_MASK | DMA_DCR_D_REQ_MASK;

			I2C1->C1 = I2C_C1_IICEN_MASK | I2C_C1_IICIE_MASK | I2C_C1_MST_MASK | I2C_C1_DMAEN_MASK;
			I2C1->D;

			break;
		case I2C_FSM_RD_END:
			i2c_fsm = I2C_FSM_STOP;

			I2C1->C1 = I2C_C1_IICEN_MASK | I2C_C1_IICIE_MASK | I2C_C1_MST_MASK | I2C_C1_TX_MASK;
			data[XFER_DATA_LEN - 1u] = I2C1->D;
			I2C1->C1 = I2C_C1_IICEN_MASK | I2C_C1_IICIE_MASK;

			break;
		default:
			assert(0);
			break;
		}
	}
}

void disp_init(void)
{
	PORT_DISP_I2C0_SCL_ALT1->PCR[IOIND_DISP_I2C0_SCL_ALT1] =
			PORT_PCR_MUX(PORT_PCR_MUX_VAL_ALT2);

	PORT_DISP_I2C0_SDA_ALT1->PCR[PORT_DISP_I2C0_SDA_ALT1] =
			PORT_PCR_MUX(PORT_PCR_MUX_VAL_ALT2);

	NVIC_SetPriority(I2C0_IRQn, 0);
	NVIC_EnableIRQ(I2C0_IRQn);

	I2C0->F = I2C_F_ICR(DISP_I2C_FDIV_400K);
	I2C0->FLT = I2C_FLT_STOPIE_MASK;
	I2C0->C1 = I2C_C1_IICEN_MASK | I2C_C1_IICIE_MASK;

	I2C0->C1 = I2C_C1_IICEN_MASK | I2C_C1_IICIE_MASK | I2C_C1_MST_MASK | I2C_C1_TX_MASK | I2C_C1_DMAEN_MASK;
	I2C1->D = IIC_MAKE_CTRL_WR(IIC_ADDR_DISP);
}
